<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BatchNorm vs LayerNorm – 同维度输出矩阵（p5.js）</title>
  <style>
    :root{ --bg:#fff; --ink:#111; --muted:#6b7280; --line:#e5e7eb; }
    html,body{height:100%;}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    header{display:flex;flex-direction:column;gap:8px;padding:12px 16px;border-bottom:1px solid var(--line);}
    .row{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .sub{color:var(--muted);font-size:12px}
    #controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    button{padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer}
    button:hover{background:#f9fafb}
    .legend{display:flex;gap:16px;align-items:center}
    .chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:#f3f4f6;font-size:12px;color:#374151}
    .dot{width:10px;height:10px;border-radius:999px}
    .bn{background:#2563eb}
    .ln{background:#16a34a}
    .hov{background:#ef4444}
    #host{min-height:calc(100% - 110px);}
    input[type="range"]{vertical-align:middle}
    label{font-size:12px;color:#374151}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <div>
        <div><strong>BatchNorm vs LayerNorm — 同维度输出矩阵演示（B=10, F=32）</strong></div>
        <div class="sub">左：BatchNorm（按列、等整批<strong>并行</strong>计算）；右：LayerNorm（按行、样本到即算）。下方输出矩阵均为 10×32。<strong>初始/结束状态</strong>：点击 BN 的列或 LN 的行，会显示组箭头并在下方渲染对应的列/行；<strong>悬停</strong>红色高亮提示。</div>
      </div>
      <div class="legend">
        <span class="chip"><span class="dot bn"></span>BN（蓝）</span>
        <span class="chip"><span class="dot ln"></span>LN（绿）</span>
        <span class="chip"><span class="dot hov"></span>Hover（红）</span>
      </div>
    </div>
    <div id="controls" class="row">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button id="btnPlay">▶️ 同步演示：BN 整批并行 / LN 即时</button>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <label>并行度（一次进入的样本数，模拟 GPU）：<input id="par" type="range" min="1" max="5" value="3"/> <span id="parVal">3</span></label>
      </div>
    </div>
  </header>
  <div id="host"></div>

  <script>
  const BATCH = 10, FEATURES = 32;
  const CELL = 16, GAP = 2, PAD = 100;

  const COL_BN = [37,99,235];     // 蓝
  const COL_LN = [22,163,74];     // 绿
  const COL_HOV = [239,68,68];    // 红（hover）
  const COL_LINK = [245,158,11];  // Amber 橙（显眼框）

  let values = [];

  // 选择 & 悬停（静态态）
  let bnClickSel = -1; // 列选择（BN）
  let lnClickSel = -1; // 行选择（LN）
  let hoverBN = {r:-1,c:-1};
  let hoverLN = {r:-1,c:-1};

  // 布局矩形
  let W,H;
  let bnRect, lnRect;        // 主输入网格（10×32）
  let bnOutRect, lnOutRect;  // 下方输出网格（10×32）
  let runStatsRect;          // 合并后的 running mean/var（2×32）

  // 动画状态
  const MODE_IDLE = 'idle', MODE_BOTH = 'anim_both';
  let mode = MODE_IDLE;
  let par = 3; // 并行度
  let arrived = 0; // 已到达的样本行数

  // LN：即时落地
  let lnTransferred = new Set();
  let activeLnRow = -1;

  // BN：整批并行阶段
  let bnReady = false;
  let bnTransferring = false;   // BN 主→BN 输出 蓝箭头 & 橙色列框
  let bnBurstTicks = 0;
  let bnTransferredAll = false;

  // BN running stats（模拟）
  let runningMean = new Array(FEATURES).fill(0);
  let runningVar  = new Array(FEATURES).fill(1);
  const MOMENTUM = 0.9;
  let runningBlinkTicks = 0;

  // BN 输出 → running（箭头 & 橙色列框）
  let runUpdating = false;
  let runUpdateTicks = 0;

  // BN 输出完成后的短暂停留（仅展示 BN 输出高亮）
  let runStage = 0;      // 0: 无；1: 仅显示 BN 输出高亮（暂停一步）
  let runStageTicks = 0;

  // 并行度框
  let recentStart = -1, recentEnd = -1;

  let lastStepMs = 0; const STEP_MS = 650;

  // 动画结束后的“保持高亮”锁（点击上方主矩阵恢复）
  let holdAfterAnim = false;

  // 记录：哪些行已经进入过“并行框”（用于动画时显示“已训练过”的行）
  let processedRows = new Set();

  // LN 最后一批的橙色外框短暂停留
  let lnBandHoldTicks = 0;

  // 控件
  const btnPlay = document.getElementById('btnPlay');
  const parInp = document.getElementById('par');
  const parVal = document.getElementById('parVal');
  parInp.oninput = ()=>{ par = +parInp.value; parVal.textContent = par; };
  btnPlay.onclick = ()=> startAnim();

  function startAnim(){
    mode = MODE_BOTH;
    regenerate();
    bnClickSel = -1; lnClickSel = -1;
    arrived = 0; lnTransferred.clear(); activeLnRow = -1;
    processedRows = new Set();
    bnReady = false; bnTransferring = false; bnBurstTicks = 0; bnTransferredAll = false;
    recentStart = -1; recentEnd = -1; runningBlinkTicks = 0;
    runUpdating = false; runUpdateTicks = 0; runStage = 0; runStageTicks = 0;
    lastStepMs = 0; holdAfterAnim = false;
    lnBandHoldTicks = 0;
  }
  function stopAnim(){
    mode = MODE_IDLE;
    bnTransferredAll = true;
    lnTransferred = new Set(Array.from({length:BATCH}, (_,i)=>i)); // LN 输出保持高亮
    activeLnRow = -1; bnTransferring = false; bnReady = false;
    recentStart = -1; recentEnd = -1;
    bnClickSel = -1; lnClickSel = -1;
    holdAfterAnim = true;
    lnBandHoldTicks = 0;
  }

  function applyRunningUpdateFromBatch(){
    for(let c=0;c<FEATURES;c++){
      const {mean, std} = colStats(c);
      const varc = std*std;
      runningMean[c] = MOMENTUM*runningMean[c] + (1-MOMENTUM)*mean;
      runningVar[c]  = MOMENTUM*runningVar[c]  + (1-MOMENTUM)*varc;
    }
    runningBlinkTicks = 6;
  }

  function regenerate(){
    values = [];
    for(let i=0;i<BATCH;i++){
      const sampleBias = randn()*0.5;
      const row = [];
      for(let j=0;j<FEATURES;j++){
        const featBias = Math.sin(j/5)*0.5;
        row.push(randn()*0.8 + sampleBias + featBias);
      }
      values.push(row);
    }
  }

  function valueGray(v, vmin, vmax){
    const t = (v - vmin) / (vmax - vmin + 1e-6);
    const g = Math.round(210 - 170*t);
    return [g,g,g];
  }
  function drawArrow(p, x1,y1,x2,y2, col=[0,0,0]){
    p.push(); p.stroke(...col); p.fill(...col); p.strokeWeight(1.8);
    p.line(x1,y1,x2,y2);
    const ang = Math.atan2(y2-y1, x2-x1);
    const ah = 8, aw = 6; p.translate(x2,y2); p.rotate(ang);
    p.triangle(-ah, -aw, -ah, aw, 0, 0); p.pop();
  }

  function colStats(col){
    let s=0; for(let i=0;i<BATCH;i++) s += values[i][col];
    const mean = s/BATCH; let v=0; for(let i=0;i<BATCH;i++){ const d=values[i][col]-mean; v+=d*d; }
    const std = Math.sqrt(v/BATCH) || 1e-6; return {mean,std};
  }
  function rowStats(row){
    let s=0; for(let j=0;j<FEATURES;j++) s += values[row][j];
    const mean = s/FEATURES; let v=0; for(let j=0;j<FEATURES;j++){ const d=values[row][j]-mean; v+=d*d; }
    const std = Math.sqrt(v/FEATURES) || 1e-6; return {mean,std};
  }

  let sketch = (p)=>{
    window._p5inst = p;

    p.setup = ()=>{
      const host = document.getElementById('host');
      W = host.clientWidth; H = host.clientHeight;
      p.createCanvas(W, H).parent(host);
      p.textFont('ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial');
      regenerate(); layout();
    };

    p.windowResized = ()=>{ const host = document.getElementById('host'); W = host.clientWidth; H = host.clientHeight; p.resizeCanvas(W,H); layout(); };

    p.mouseMoved = ()=>{ if(mode===MODE_IDLE || holdAfterAnim){ const m={x:p.mouseX,y:p.mouseY}; hoverBN=hitGrid(m,bnRect); hoverLN=hitGrid(m,lnRect);} };

    p.mouseClicked = ()=>{
      const m={x:p.mouseX,y:p.mouseY};
      if(mode!==MODE_IDLE) return;
      if(holdAfterAnim){
        if(inRect(m, bnRect) || inRect(m, lnRect)){
          holdAfterAnim = false;
          bnTransferredAll = false;
          lnTransferred.clear();
          bnClickSel = -1; lnClickSel = -1;
        }
        return;
      }
      const hb=hitGrid(m,bnRect); const hl=hitGrid(m,lnRect);
      if(hb.c>=0){ bnClickSel = hb.c; }
      if(hl.r>=0){ lnClickSel = hl.r; }
    };

    p.draw = ()=>{
      p.background(255);
      const needH = Math.max(
        (bnOutRect?.y||0)+(bnOutRect?.h||0),
        (lnOutRect?.y||0)+(lnOutRect?.h||0),
        (runStatsRect?.y||0)+(runStatsRect?.h||0)
      ) + PAD;
      if (p.height < needH){ H = needH; p.resizeCanvas(W, H); }

      tickAnim(p);

      // 绘制顺序：底层内容 → 箭头 → ★最后画橙色高亮（bring to front）
      drawGrid(p, bnRect, 'BN');
      drawGrid(p, lnRect, 'LN');
      drawTitles(p);
      drawOutGrid(p, bnOutRect, 'BN');
      drawOutGrid(p, lnOutRect, 'LN');
      drawRunningStatsMerged(p);     // 先画 running 的内容
      drawParallelBands(p);
      drawAnimArrows(p);
      drawRunUpdateArrows(p);
      drawClickArrows(p);

      // ★ 橙色“列/行”高亮最后绘制，确保在最前层
      drawStageHighlights(p);

      drawHoldHint(p);
    };
  };

  function layout(){
    const gridW = FEATURES*(CELL+GAP)-GAP;
    const gridH = BATCH*(CELL+GAP)-GAP;
    const colGap = 120;
    const outGap = 56;

    const xBN = PAD + 70; // 左边留出“train x”标签
    const yTop = PAD + 36;
    bnRect = {x:xBN, y:yTop, w:gridW, h:gridH};
    const xLN = xBN + gridW + colGap; const yLN = yTop;
    lnRect = {x:xLN, y:yLN, w:gridW, h:gridH};

    bnOutRect = {x: bnRect.x, y: bnRect.y + gridH + outGap, w:gridW, h:gridH};
    lnOutRect = {x: lnRect.x, y: lnRect.y + gridH + outGap, w:gridW, h:gridH};

    // 合并后的 running (2×32)：放在 BN 输出矩阵下方
    const rvGap = 36;
    runStatsRect = {
      x: bnOutRect.x,
      y: bnOutRect.y + gridH + rvGap,
      w: gridW,
      h: 2*(CELL+GAP)-GAP // 两行
    };
  }

  function drawTitles(p){
    p.push(); p.noStroke(); p.fill(17); p.textSize(14);
    p.text('BatchNorm（按列归一化 · 整批并行）', bnRect.x, bnRect.y-12);
    p.text('LayerNorm（按行归一化 · 即时）', lnRect.x, lnRect.y-12);
    p.fill(60); p.textSize(12);
    p.text('BN 输出（10×32）', bnOutRect.x, bnOutRect.y - 10);
    p.text('LN 输出（10×32）', lnOutRect.x, lnOutRect.y - 10);

    // 顶部主矩阵左侧“train”标签
    p.fill(55); p.textSize(12);
    const labelX = bnRect.x - 64;
    const rowsY = (r)=> bnRect.y + r*(CELL+GAP) + CELL*0.75;
    p.text('train 1',  labelX, rowsY(0));
    p.text('train 2',  labelX, rowsY(1));
    p.text('…',        labelX+14, rowsY(2));
    p.text('train 10', labelX-6, rowsY(9));

    const labelX2 = lnRect.x - 64;
    const rowsY2 = (r)=> lnRect.y + r*(CELL+GAP) + CELL*0.75;
    p.text('train 1',  labelX2, rowsY2(0));
    p.text('train 2',  labelX2, rowsY2(1));
    p.text('…',        labelX2+14, rowsY2(2));
    p.text('train 10', labelX2-6, rowsY2(9));

    // running 标签：分别标注到两行的左边
    p.text('running mean（1×32）', runStatsRect.x - 160, runStatsRect.y + CELL*0.75);
    p.text('running var（1×32）',  runStatsRect.x - 160, runStatsRect.y + (CELL+GAP) + CELL*0.75);

    // 顶部列标签（f1, f2, …, f32）
    p.fill(55); p.textSize(12);
    for(let c=0;c<FEATURES;c++){
      const x1 = bnRect.x + c*(CELL+GAP) + 2;
      const x2 = lnRect.x + c*(CELL+GAP) + 2;
      if(c===0){ p.text('f1', x1, bnRect.y - 16); p.text('f1', x2, lnRect.y - 16);}
      else if(c===1){ p.text('f2', x1, bnRect.y - 16); p.text('f2', x2, lnRect.y - 16);}
      else if(c===FEATURES-1){ p.text('f32', x1-6, bnRect.y - 16); p.text('f32', x2-6, lnRect.y - 16);}
      else if(c===2){ p.text('…', x1, bnRect.y - 16); p.text('…', x2, lnRect.y - 16);}
    }
    p.pop();
  }

  function drawGrid(p, rect, type){
    const flat = values.flat(); const vmin = Math.min(...flat), vmax = Math.max(...flat);
    p.noFill(); p.stroke(229); p.rect(rect.x-8, rect.y-8, rect.w+16, rect.h+16, 10);

    const isAnim = (mode===MODE_BOTH);
    const inBand = (r)=> (recentStart>=0 && recentEnd>recentStart && r>=recentStart && r<recentEnd);

    for(let r=0; r<BATCH; r++){
      if(isAnim){
        const wasCovered = processedRows.has(r);
        if(!(inBand(r) || wasCovered)) continue;
      }
      for(let c=0;c<FEATURES;c++){
        const x = rect.x + c*(CELL+GAP);
        const y = rect.y + r*(CELL+GAP);
        const col = valueGray(values[r][c], vmin, vmax);
        p.noStroke(); p.fill(...col); p.rect(x,y,CELL,CELL,3);
      }
    }

    if(mode!==MODE_BOTH){
      if(type==='BN' && bnClickSel>=0){ const c=bnClickSel; for(let r=0;r<BATCH;r++){ const x=rect.x+c*(CELL+GAP); const y=rect.y+r*(CELL+GAP); p.noFill(); p.stroke(...COL_BN); p.strokeWeight(2); p.rect(x-1,y-1,CELL+2,CELL+2,4);} }
      if(type==='LN' && lnClickSel>=0){ const r=lnClickSel; for(let c=0;c<FEATURES;c++){ const x=rect.x+c*(CELL+GAP); const y=rect.y+r*(CELL+GAP); p.noFill(); p.stroke(...COL_LN); p.strokeWeight(2); p.rect(x-1,y-1,CELL+2,CELL+2,4);} }
    }

    if((mode===MODE_IDLE || holdAfterAnim)){
      if(type==='BN' && hoverBN.c>=0){ const c=hoverBN.c; for(let r=0;r<BATCH;r++){ const x=rect.x+c*(CELL+GAP); const y=rect.y+r*(CELL+GAP); p.noFill(); p.stroke(...COL_HOV); p.strokeWeight(2); p.rect(x-1,y-1,CELL+2,CELL+2,4);} }
      if(type==='LN' && hoverLN.r>=0){ const r=hoverLN.r; for(let c=0;c<FEATURES;c++){ const x=rect.x+c*(CELL+GAP); const y=rect.y+r*(CELL+GAP); p.noFill(); p.stroke(...COL_HOV); p.strokeWeight(2); p.rect(x-1,y-1,CELL+2,CELL+2,4);} }
    }
  }

  function drawOutGrid(p, rect, type){
    p.noFill(); p.stroke(229); p.rect(rect.x-8, rect.y-8, rect.w+16, rect.h+16, 10);
    if(type==='LN'){
      for(const r of lnTransferred){
        const {mean,std} = rowStats(r);
        for(let c=0;c<FEATURES;c++){
          const x = rect.x + c*(CELL+GAP);
          const y = rect.y + r*(CELL+GAP);
          const v = (values[r][c]-mean)/std; const t = 1/(1+Math.exp(-v)); const g = Math.round(210 - 170*t);
          p.noStroke(); p.fill(g,g,g); p.rect(x,y,CELL,CELL,3);
          p.noFill(); p.stroke(...COL_LN); p.strokeWeight(1.4); p.rect(x-1,y-1,CELL+2,CELL+2,4);
        }
      }
      if(mode===MODE_IDLE && lnClickSel>=0 && !holdAfterAnim){
        const r = lnClickSel; const {mean,std} = rowStats(r);
        for(let c=0;c<FEATURES;c++){
          const x = rect.x + c*(CELL+GAP);
          const y = rect.y + r*(CELL+GAP);
          const v = (values[r][c]-mean)/std; const t = 1/(1+Math.exp(-v)); const g = Math.round(210 - 170*t);
          p.noStroke(); p.fill(g,g,g); p.rect(x,y,CELL,CELL,3);
          p.noFill(); p.stroke(...COL_LN); p.strokeWeight(1.4); p.rect(x-1,y-1,CELL+2,CELL+2,4);
        }
      }
    } else {
      if(bnTransferredAll){
        for(let cIdx=0;cIdx<FEATURES;cIdx++){
          const {mean,std} = colStats(cIdx);
          for(let r=0;r<BATCH;r++){
            const x = rect.x + cIdx*(CELL+GAP);
            const y = rect.y + r*(CELL+GAP);
            const v = (values[r][cIdx]-mean)/std; const t = 1/(1+Math.exp(-v)); const g = Math.round(210 - 170*t);
            p.noStroke(); p.fill(g,g,g); p.rect(x,y,CELL,CELL,3);
            p.noFill(); p.stroke(...COL_BN); p.strokeWeight(1.4); p.rect(x-1,y-1,CELL+2,CELL+2,4);
          }
        }
      }
      if(mode===MODE_IDLE && bnClickSel>=0 && !holdAfterAnim){
        const cIdx = bnClickSel; const {mean,std} = colStats(cIdx);
        for(let r=0;r<BATCH;r++){
          const x = rect.x + cIdx*(CELL+GAP);
          const y = rect.y + r*(CELL+GAP);
          const v = (values[r][cIdx]-mean)/std; const t = 1/(1+Math.exp(-v)); const g = Math.round(210 - 170*t);
          p.noStroke(); p.fill(g,g,g); p.rect(x,y,CELL,CELL,3);
          p.noFill(); p.stroke(...COL_BN); p.strokeWeight(1.4); p.rect(x-1,y-1,CELL+2,CELL+2,4);
        }
      }
    }
  }

  // —— 橙色“列/行”高亮：与箭头或并行段同步（最后绘制，bring to front） ——
  function drawStageHighlights(p){
    // A) BN 主→BN 输出：蓝箭头同步（bnTransferring），两侧 32 列逐列画橙框
    if(bnTransferring){
      for(let c=0;c<FEATURES;c++){
        drawColOutline(p, bnRect,    c, COL_LINK);
        drawColOutline(p, bnOutRect, c, COL_LINK);
      }
    }
    // B) BN 输出→running：蓝箭头同步（runUpdating），对 running(2×32) **逐列**画橙框（每列一个，覆盖两行）
    if(runUpdating){
      for(let c=0;c<FEATURES;c++){
        drawColOutline(p, bnOutRect,    c, COL_LINK);
        drawColOutline(p, runStatsRect, c, COL_LINK);
      }
    }
    // C) LN 主→LN 输出：训练中**逐行**画橙色行框（而不是大外框）
    const showLnRows = (mode===MODE_BOTH) && ( (arrived < BATCH) || (lnBandHoldTicks>0) ) && (recentStart>=0) && (recentEnd>recentStart);
    if(showLnRows){
      for(let r=recentStart; r<recentEnd; r++){
        drawRowOutline(p, lnRect,    r, COL_LINK);
        drawRowOutline(p, lnOutRect, r, COL_LINK);
      }
    }
  }
  function drawColOutline(p, rect, c, col){
    const x = rect.x + c*(CELL+GAP) - 2;
    const y = rect.y - 2;
    const w = CELL + 4;
    const h = rect.h + 4; // 对 runStatsRect：覆盖两行，实现“每列一个框”
    p.noFill(); p.stroke(col[0], col[1], col[2], 196); p.strokeWeight(5);
    p.rect(x, y, w, h, 6);
    p.stroke(col[0], col[1], col[2], 255); p.strokeWeight(2.2);
    p.rect(x, y, w, h, 6);
  }
  function drawRowOutline(p, rect, r, col){
    const x = rect.x - 2;
    const y = rect.y + r*(CELL+GAP) - 2;
    const w = rect.w + 4;
    const h = CELL + 4;
    p.noFill(); p.stroke(col[0], col[1], col[2], 196); p.strokeWeight(5);
    p.rect(x, y, w, h, 6);
    p.stroke(col[0], col[1], col[2], 255); p.strokeWeight(2.2);
    p.rect(x, y, w, h, 6);
  }

  // —— 合并的 running(mean/var) 2×32 绘制 ——
  function drawRunningStatsMerged(p){
    // 外框
    p.noFill(); p.stroke(229);
    p.rect(runStatsRect.x-8, runStatsRect.y-8, runStatsRect.w+16, runStatsRect.h+16, 10);

    // 哪些列显示：
    const showAll = runUpdating || holdAfterAnim;
    const selectedCol = (mode===MODE_IDLE && !holdAfterAnim && bnClickSel>=0) ? bnClickSel : -1;
    const colsToDraw = showAll ? Array.from({length:FEATURES}, (_,i)=>i) : (selectedCol>=0 ? [selectedCol] : []);

    if(colsToDraw.length===0){
      if(runningBlinkTicks>0) runningBlinkTicks--;
      return;
    }

    const rmMin = Math.min(...runningMean), rmMax = Math.max(...runningMean);
    const rvMin = Math.min(...runningVar),  rvMax = Math.max(...runningVar);

    for(const c of colsToDraw){
      // 上行：mean
      const x1 = runStatsRect.x + c*(CELL+GAP);
      const y1 = runStatsRect.y + 0*(CELL+GAP);
      const t1 = (runningMean[c]-rmMin)/(rmMax-rmMin+1e-6); const g1 = Math.round(210 - 170*t1);
      p.noStroke(); p.fill(g1,g1,g1); p.rect(x1,y1,CELL,CELL,3);

      // 下行：var
      const x2 = runStatsRect.x + c*(CELL+GAP);
      const y2 = runStatsRect.y + 1*(CELL+GAP);
      const t2 = (runningVar[c]-rvMin)/(rvMax-rvMin+1e-6);  const g2 = Math.round(210 - 170*t2);
      p.noStroke(); p.fill(g2,g2,g2); p.rect(x2,y2,CELL,CELL,3);
    }

    // 蓝边框高亮（更新时更亮）
    const blinkAlpha = runningBlinkTicks>0 ? 255 : 180;
    if(runningBlinkTicks>0) runningBlinkTicks--;
    p.noFill(); p.stroke(37,99,235, blinkAlpha); p.strokeWeight(2);
    for(const c of colsToDraw){
      const x1 = runStatsRect.x + c*(CELL+GAP); const y1 = runStatsRect.y + 0*(CELL+GAP);
      p.rect(x1-1,y1-1,CELL+2,CELL+2,4);
      const x2 = runStatsRect.x + c*(CELL+GAP); const y2 = runStatsRect.y + 1*(CELL+GAP);
      p.rect(x2-1,y2-1,CELL+2,CELL+2,4);
    }

    // 静态点击时：从 BN 输出 → running(两行中心) 画 1 条箭头
    if(!showAll && selectedCol>=0){
      const sx = bnOutRect.x + selectedCol*(CELL+GAP) + CELL/2;
      const sy = bnOutRect.y + (BATCH*(CELL+GAP)-GAP);
      const tx = runStatsRect.x + selectedCol*(CELL+GAP) + CELL/2;
      const ty0 = runStatsRect.y + 0*(CELL+GAP) + CELL/2;
      const ty1 = runStatsRect.y + 1*(CELL+GAP) + CELL/2;
      const ty  = (ty0 + ty1)/2;
      drawArrow(window._p5inst || p, sx, sy, tx, ty, COL_BN);
    }
  }

  // —— 箭头（动画） ——
  function drawAnimArrows(p){
    if(mode!==MODE_BOTH) return;
    // LN：行组箭头（仅当前活动行）
    if(activeLnRow>=0){
      const r = activeLnRow;
      const sx = lnRect.x + (FEATURES*(CELL+GAP)-GAP)/2;
      const sy = lnRect.y + r*(CELL+GAP) + CELL/2;
      const tx = lnOutRect.x + (FEATURES*(CELL+GAP)-GAP)/2;
      const ty = lnOutRect.y + r*(CELL+GAP) + CELL/2;
      drawArrow(p, sx, sy, tx, ty, COL_LN);
    }
    // BN：32 列组箭头（主→输出）
    if(bnTransferring){
      for(let c=0;c<FEATURES;c++){
        const sx = bnRect.x + c*(CELL+GAP) + CELL/2;
        const sy = bnRect.y + (BATCH*(CELL+GAP)-GAP)/2;
        const tx = bnOutRect.x + c*(CELL+GAP) + CELL/2;
        const ty = bnOutRect.y + (BATCH*(CELL+GAP)-GAP)/2;
        drawArrow(p, sx, sy, tx, ty, COL_BN);
      }
    }
  }

  // BN 输出 → running(mean/var) 的 32 组箭头
  function drawRunUpdateArrows(p){
    if(!runUpdating) return;
    for(let c=0;c<FEATURES;c++){
      const sx = bnOutRect.x + c*(CELL+GAP) + CELL/2;
      const sy = bnOutRect.y + (BATCH*(CELL+GAP)-GAP);
      const tx = runStatsRect.x + c*(CELL+GAP) + CELL/2;
      const ty0 = runStatsRect.y + 0*(CELL+GAP) + CELL/2;
      const ty1 = runStatsRect.y + 1*(CELL+GAP) + CELL/2;
      const ty = (ty0 + ty1)/2; // 指向 mean/var 两格之间的中点
      drawArrow(p, sx, sy, tx, ty, COL_BN);
    }
  }

  // —— 静态点击箭头 ——
  function drawClickArrows(p){
    if(mode!==MODE_IDLE) return;
    if(bnClickSel>=0){
      const c = bnClickSel;
      const sx = bnRect.x + c*(CELL+GAP) + CELL/2;
      const sy = bnRect.y + (BATCH*(CELL+GAP)-GAP)/2;
      const tx = bnOutRect.x + c*(CELL+GAP) + CELL/2;
      const ty = bnOutRect.y + (BATCH*(CELL+GAP)-GAP)/2;
      drawArrow(p, sx, sy, tx, ty, COL_BN);
    }
    if(lnClickSel>=0){
      const r = lnClickSel;
      const sx = lnRect.x + (FEATURES*(CELL+GAP)-GAP)/2;
      const sy = lnRect.y + r*(CELL+GAP) + CELL/2;
      const tx = lnOutRect.x + (FEATURES*(CELL+GAP)-GAP)/2;
      const ty = lnOutRect.y + r*(CELL+GAP) + CELL/2;
      drawArrow(p, sx, sy, tx, ty, COL_LN);
    }
  }

  // —— 动画主循环 —— 
  function tickAnim(p){
    if(mode===MODE_IDLE) return;
    const now = p.millis();
    if(lastStepMs===0 || now - lastStepMs >= STEP_MS){
      lastStepMs = now;
      if(arrived < BATCH){
        const add = Math.min(par, BATCH - arrived);
        const start = arrived, end = arrived + add;
        recentStart = start; recentEnd = end;
        for(let r=start; r<end; r++){ lnTransferred.add(r); processedRows.add(r); activeLnRow = r; }
        arrived += add;
        if(arrived >= BATCH){
          bnReady = true;
          lnBandHoldTicks = 2; // 最后一批到达后，LN 行框再停留 2 拍
        }
      } else if(bnReady){
        // 显示 32 组蓝箭头（bnTransferring=true）→ 一次性填满 BN 输出
        recentStart = 0; recentEnd = BATCH;
        if(!bnTransferring){ bnTransferring = true; bnBurstTicks = 2; }
        else {
          bnBurstTicks--;
          if(bnBurstTicks <= 0){
            bnTransferring = false;
            bnTransferredAll = true; // BN 输出已填满
            // 进入短暂停留（只展示 BN 输出高亮）
            runStage = 1; runStageTicks = 2;
            bnReady = false; activeLnRow = -1;
          }
        }
      }
      else if(runStage===1){
        runStageTicks--;
        if(runStageTicks<=0){
          // 进入 BN 输出 → running 的箭头阶段（runUpdating=true）
          runStage = 0;
          runUpdating = true; runUpdateTicks = 2;
        }
      }
      else if(runUpdating){
        runUpdateTicks--;
        if(runUpdateTicks <= 0){
          runUpdating = false;
          applyRunningUpdateFromBatch();
          stopAnim(); // 进入保持高亮锁
        }
      }

      // 递减 LN 最后一批行框的停留计数
      if(lnBandHoldTicks > 0) lnBandHoldTicks--;
    }
  }

  function drawParallelBands(p){
    if(mode!==MODE_BOTH) return;
    if(recentStart<0 || recentEnd<=recentStart) return;
    const bandY = (r)=> r*(CELL+GAP);
    const h = (recentEnd - recentStart)*(CELL+GAP) - GAP;
    p.push();
    // BN
    p.noFill(); p.stroke(0,0,0,60); p.strokeWeight(2);
    p.rect(bnRect.x-6, bnRect.y + bandY(recentStart) - 6, bnRect.w+12, h+12, 8);
    p.noStroke(); p.fill(0,0,0,120); p.textSize(11);
    p.text(`并行度：${par}`, bnRect.x-6, bnRect.y + bandY(recentStart) - 10);
    // LN
    p.noFill(); p.stroke(0,0,0,60); p.strokeWeight(2);
    p.rect(lnRect.x-6, lnRect.y + bandY(recentStart) - 6, lnRect.w+12, h+12, 8);
    p.noStroke(); p.fill(0,0,0,120); p.textSize(11);
    p.text(`并行度：${par}`, lnRect.x-6, lnRect.y + bandY(recentStart) - 10);
    p.pop();
  }

  function inRect(m, rect){
    return (m.x>=rect.x && m.x<=rect.x+rect.w && m.y>=rect.y && m.y<=rect.y+rect.h);
  }
  function hitGrid(m, rect){
    const {x,y,w,h} = rect; const cell=CELL, gap=GAP;
    if(m.x<x||m.y<y||m.x>x+w||m.y>y+h) return {r:-1,c:-1};
    const c=Math.floor((m.x-x)/(cell+gap));
    const r=Math.floor((m.y-y)/(cell+gap));
    if(r<0||r>=BATCH||c<0||c>=FEATURES) return {r:-1,c:-1};
    return {r,c};
  }

  function drawHoldHint(p){
    if(!holdAfterAnim) return;
    p.push();
    p.noStroke(); p.fill(17, 17, 17, 160); p.textSize(12);
    const msg = '动画已完成：点击上面的任一主矩阵恢复到普通交互（Hover 依然有效）';
    const tx = Math.min(bnOutRect.x, lnOutRect.x);
    const ty = Math.min(bnOutRect.y, lnOutRect.y) - 24;
    p.text(msg, tx, ty);
    p.pop();
  }

  function randn(){ let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}

  new p5(sketch);
  </script>
</body>
</html>
